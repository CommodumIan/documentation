---
id: block-explorer-service-list-transactions
title: "BlockExplorerService_ListTransactions"
description: "BlockExplorerService_ListTransactions"
sidebar_label: BlockExplorerService_ListTransactions
hide_title: true
hide_table_of_contents: true
api: {"operationId":"BlockExplorerService_ListTransactions","responses":{"200":{"description":"A successful response.","content":{"application/json":{"schema":{"type":"object","properties":{"transactions":{"type":"array","items":{"type":"object","properties":{"block":{"type":"string","format":"uint64"},"index":{"type":"integer","format":"int64"},"hash":{"type":"string"},"submitter":{"type":"string"},"type":{"type":"string"},"code":{"type":"integer","format":"int64"},"cursor":{"type":"string"},"command":{"type":"object","properties":{"nonce":{"type":"string","format":"uint64","description":"A number to provide uniqueness to prevent accidental replays and,\nin combination with `block_height`, deliberate attacks.\nA nonce provides uniqueness for otherwise identical transactions,\nensuring that the transaction hash uniquely identifies a specific transaction.\nGranted all other fields are equal, the nonce can either be a counter\nor generated at random to submit multiple transactions within the same\nblock (see below), without being identified as replays.\nPlease note that Protocol Buffers do not have a canonical, unique encoding\nand therefore different libraries or binaries may encode the same message\nslightly differently, causing a different hash."},"blockHeight":{"type":"string","format":"uint64","description":"The block height at which the transaction was made.\nThis should be the current block height. The transaction will be valid\nfrom the block and up to the `tolerance` block height.\nExample: If the network has a tolerance of 150 blocks and `block_height`\nis set to `200`, then the transaction will be valid until block `350`.\nNote that a `block_height` that is ahead of the real block height will be\nrejected. The tolerance can be queried from the chain's network parameters.\n`block_height` prevents replay attacks in conjunction with `nonce` (see above)."},"orderSubmission":{"title":"User commands","type":"object","properties":{"marketId":{"type":"string","title":"Market identifier for the order, required field"},"price":{"type":"string","title":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\n, required field for limit orders, however it is not required for market orders"},"size":{"type":"string","format":"uint64","title":"Size for the order, for example, in a futures market the size equals the number of units, cannot be negative"},"side":{"title":"Side for the order, e.g. SIDE_BUY or SIDE_SELL, required field\n- See `Side`","type":"string","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"default":"SIDE_UNSPECIFIED","description":"- SIDE_UNSPECIFIED: Default value, always invalid\n - SIDE_BUY: Buy order\n - SIDE_SELL: Sell order"},"timeInForce":{"title":"Time in force indicates how long an order will remain active before it is executed or expires, required field\n- See `Order.TimeInForce`","type":"string","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"default":"TIME_IN_FORCE_UNSPECIFIED","description":"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"},"expiresAt":{"type":"string","format":"int64","title":"Timestamp for when the order will expire, in nanoseconds since the epoch,\nrequired field only for `Order.TimeInForce`.TIME_IN_FORCE_GTT`\n- See `VegaTimeResponse`.`timestamp`"},"type":{"title":"Type for the order, required field - See `Order.Type`","type":"string","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"default":"TYPE_UNSPECIFIED","description":"- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_LIMIT: Used for Limit orders\n - TYPE_MARKET: Used for Market orders\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)"},"reference":{"type":"string","title":"Reference given for the order, this is typically used to retrieve an order submitted through consensus, currently\nset internally by the node to return a unique reference identifier for the order submission"},"peggedOrder":{"title":"Used to specify the details for a pegged order\n- See `PeggedOrder`","type":"object","properties":{"reference":{"title":"The price point the order is linked to","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"},"offset":{"type":"string","title":"Offset from the price reference"}}}}},"orderCancellation":{"type":"object","properties":{"orderId":{"type":"string","title":"Unique identifier for the order (set by the system after consensus), required field"},"marketId":{"type":"string","title":"Market identifier for the order, required field"}},"title":"An order cancellation is a request to cancel an existing order on Vega"},"orderAmendment":{"type":"object","properties":{"orderId":{"type":"string","title":"Order identifier, this is required to find the order and will not be updated, required field"},"marketId":{"type":"string","title":"Market identifier, this is required to find the order and will not be updated"},"price":{"type":"string","title":"Amend the price for the order, if the Price value is set, otherwise price will remain unchanged - See [`Price`](#vega.Price)"},"sizeDelta":{"type":"string","format":"int64","title":"Amend the size for the order by the delta specified:\n- To reduce the size from the current value set a negative integer value\n- To increase the size from the current value, set a positive integer value\n- To leave the size unchanged set a value of zero"},"expiresAt":{"type":"string","format":"int64","title":"Amend the expiry time for the order, if the Timestamp value is set, otherwise expiry time will remain unchanged\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`"},"timeInForce":{"title":"Amend the time in force for the order, set to TIME_IN_FORCE_UNSPECIFIED to remain unchanged\n- See [`TimeInForce`](#api.VegaTimeResponse).`timestamp`","type":"string","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"default":"TIME_IN_FORCE_UNSPECIFIED","description":"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"},"peggedOffset":{"type":"string","title":"Amend the pegged order offset for the order"},"peggedReference":{"title":"Amend the pegged order reference for the order\n- See [`PeggedReference`](#vega.PeggedReference)","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"}},"title":"An order amendment is a request to amend or update an existing order on Vega"},"withdrawSubmission":{"type":"object","properties":{"amount":{"type":"string","title":"The amount to be withdrawn"},"asset":{"type":"string","title":"The asset to be withdrawn"},"ext":{"title":"Foreign chain specifics","type":"object","properties":{"erc20":{"title":"ERC20 withdrawal details","type":"object","properties":{"receiverAddress":{"type":"string","title":"The address into which the bridge will release the funds"}}}}}},"title":"Represents the submission request to withdraw funds for a party on Vega"},"proposalSubmission":{"type":"object","properties":{"reference":{"type":"string","title":"Proposal reference"},"terms":{"title":"Proposal configuration and the actual change that is meant to be executed when proposal is enacted","type":"object","properties":{"closingTimestamp":{"type":"string","format":"int64","title":"Timestamp (Unix time in seconds) when voting closes for this proposal,\nconstrained by `minClose` and `maxClose` network parameters"},"enactmentTimestamp":{"type":"string","format":"int64","title":"Timestamp (Unix time in seconds) when proposal gets enacted (if passed),\nconstrained by `minEnact` and `maxEnact` network parameters"},"validationTimestamp":{"type":"string","format":"int64","title":"Validation timestamp (Unix time in seconds)"},"updateMarket":{"title":"Proposal change for modifying an existing market on Vega","type":"object","properties":{"marketId":{"type":"string","title":"The identifier of the market to update"},"changes":{"title":"The updated configuration of the market","type":"object","properties":{"instrument":{"title":"Updated market instrument configuration","type":"object","properties":{"code":{"type":"string","title":"Instrument code, human-readable shortcode used to describe the instrument"},"future":{"title":"Future","type":"object","properties":{"quoteName":{"type":"string","title":"Human-readable name/abbreviation of the quote name"},"oracleSpecForSettlementPrice":{"title":"The oracle spec describing the oracle data of settlement price","type":"object","properties":{"pubKeys":{"type":"array","items":{"type":"string"},"description":"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."},"filters":{"type":"array","items":{"type":"object","properties":{"key":{"description":"key is the oracle data property key targeted by the filter.","type":"object","properties":{"name":{"type":"string","description":"name is the name of the property."},"type":{"description":"type is the type of the property.","type":"string","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"default":"TYPE_UNSPECIFIED"}}},"conditions":{"type":"array","items":{"type":"object","properties":{"operator":{"description":"comparator is the type of comparison to make on the value.","type":"string","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"default":"OPERATOR_UNSPECIFIED"},"value":{"type":"string","description":"value is used by the comparator."}},"title":"Condition describes the condition that must be validated by the"},"description":"conditions are the conditions that should be matched by the data to be\nconsidered of interest."}},"description":"Filter describes the conditions under which an oracle data is considered of\ninterest or not."},"description":"filters describes which oracle data are considered of interest or not for\nthe product (or the risk model)."}},"description":"An oracle spec describe the oracle data that a product (or a risk model)\nwants to get from the oracle engine."},"oracleSpecForTradingTermination":{"title":"The oracle spec describing the oracle data of trading termination","type":"object","properties":{"pubKeys":{"type":"array","items":{"type":"string"},"description":"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."},"filters":{"type":"array","items":{"type":"object","properties":{"key":{"description":"key is the oracle data property key targeted by the filter.","type":"object","properties":{"name":{"type":"string","description":"name is the name of the property."},"type":{"description":"type is the type of the property.","type":"string","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"default":"TYPE_UNSPECIFIED"}}},"conditions":{"type":"array","items":{"type":"object","properties":{"operator":{"description":"comparator is the type of comparison to make on the value.","type":"string","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"default":"OPERATOR_UNSPECIFIED"},"value":{"type":"string","description":"value is used by the comparator."}},"title":"Condition describes the condition that must be validated by the"},"description":"conditions are the conditions that should be matched by the data to be\nconsidered of interest."}},"description":"Filter describes the conditions under which an oracle data is considered of\ninterest or not."},"description":"filters describes which oracle data are considered of interest or not for\nthe product (or the risk model)."}},"description":"An oracle spec describe the oracle data that a product (or a risk model)\nwants to get from the oracle engine."},"oracleSpecBinding":{"title":"The binding between the oracle spec and the settlement price","type":"object","properties":{"settlementPriceProperty":{"type":"string","description":"settlement_price_property holds the name of the property in the oracle data\nthat should be used as settlement price.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement price."},"tradingTerminationProperty":{"type":"string","title":"the name of the property in the oracle data that signals termination of trading"}}},"settlementDataDecimals":{"type":"integer","format":"int64","title":"The number of decimal places implied by the settlement data (such as price) emitted by the settlement oracle"}}}}},"metadata":{"type":"array","items":{"type":"string"},"title":"Optional market metadata, tags"},"priceMonitoringParameters":{"title":"Price monitoring parameters","type":"object","properties":{"triggers":{"type":"array","items":{"type":"object","properties":{"horizon":{"type":"string","format":"int64","title":"Price monitoring projection horizon τ in seconds"},"probability":{"type":"string","title":"Price monitoring probability level p"},"auctionExtension":{"type":"string","format":"int64","title":"Price monitoring auction extension duration in seconds should the price\nbreach it's theoretical level over the specified horizon at the specified\nprobability level"}},"title":"PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration"}}}},"liquidityMonitoringParameters":{"title":"Liquidity monitoring parameters","type":"object","properties":{"targetStakeParameters":{"title":"Specifies parameters related to target stake calculation","type":"object","properties":{"timeWindow":{"type":"string","format":"int64","title":"Specifies length of time window expressed in seconds for target stake calculation"},"scalingFactor":{"type":"number","format":"double","title":"Specifies scaling factors used in target stake calculation"}}},"triggeringRatio":{"type":"number","format":"double","title":"Specifies the triggering ratio for entering liquidity auction"},"auctionExtension":{"type":"string","format":"int64","title":"Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction"}}},"simple":{"title":"Simple risk model parameters, valid only if MODEL_SIMPLE is selected","type":"object","properties":{"factorLong":{"type":"number","format":"double","title":"Pre-defined risk factor value for long"},"factorShort":{"type":"number","format":"double","title":"Pre-defined risk factor value for short"},"maxMoveUp":{"type":"number","format":"double","title":"Pre-defined maximum price move up that the model considers as valid"},"minMoveDown":{"type":"number","format":"double","title":"Pre-defined minimum price move down that the model considers as valid"},"probabilityOfTrading":{"type":"number","format":"double","title":"Pre-defined constant probability of trading"}}},"logNormal":{"title":"Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected","type":"object","properties":{"riskAversionParameter":{"type":"number","format":"double","title":"Risk Aversion Parameter"},"tau":{"type":"number","format":"double","title":"Tau"},"params":{"title":"Risk model parameters for log normal","type":"object","properties":{"mu":{"type":"number","format":"double","title":"Mu param"},"r":{"type":"number","format":"double","title":"R param"},"sigma":{"type":"number","format":"double","title":"Sigma param"}}}}}}}}},"newMarket":{"title":"Proposal change for creating new market on Vega","type":"object","properties":{"changes":{"title":"The configuration of the new market","type":"object","properties":{"instrument":{"title":"New market instrument configuration","type":"object","properties":{"name":{"type":"string","title":"Instrument name"},"code":{"type":"string","title":"Instrument code, human-readable shortcode used to describe the instrument"},"future":{"title":"Future","type":"object","properties":{"settlementAsset":{"type":"string","title":"Asset ID for the product's settlement asset"},"quoteName":{"type":"string","title":"Product quote name"},"oracleSpecForSettlementPrice":{"title":"The oracle spec describing the oracle data of settlement price","type":"object","properties":{"pubKeys":{"type":"array","items":{"type":"string"},"description":"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."},"filters":{"type":"array","items":{"type":"object","properties":{"key":{"description":"key is the oracle data property key targeted by the filter.","type":"object","properties":{"name":{"type":"string","description":"name is the name of the property."},"type":{"description":"type is the type of the property.","type":"string","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"default":"TYPE_UNSPECIFIED"}}},"conditions":{"type":"array","items":{"type":"object","properties":{"operator":{"description":"comparator is the type of comparison to make on the value.","type":"string","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"default":"OPERATOR_UNSPECIFIED"},"value":{"type":"string","description":"value is used by the comparator."}},"title":"Condition describes the condition that must be validated by the"},"description":"conditions are the conditions that should be matched by the data to be\nconsidered of interest."}},"description":"Filter describes the conditions under which an oracle data is considered of\ninterest or not."},"description":"filters describes which oracle data are considered of interest or not for\nthe product (or the risk model)."}},"description":"An oracle spec describe the oracle data that a product (or a risk model)\nwants to get from the oracle engine."},"oracleSpecForTradingTermination":{"title":"The oracle spec describing the oracle data of trading termination","type":"object","properties":{"pubKeys":{"type":"array","items":{"type":"string"},"description":"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."},"filters":{"type":"array","items":{"type":"object","properties":{"key":{"description":"key is the oracle data property key targeted by the filter.","type":"object","properties":{"name":{"type":"string","description":"name is the name of the property."},"type":{"description":"type is the type of the property.","type":"string","enum":["TYPE_UNSPECIFIED","TYPE_EMPTY","TYPE_INTEGER","TYPE_STRING","TYPE_BOOLEAN","TYPE_DECIMAL","TYPE_TIMESTAMP"],"default":"TYPE_UNSPECIFIED"}}},"conditions":{"type":"array","items":{"type":"object","properties":{"operator":{"description":"comparator is the type of comparison to make on the value.","type":"string","enum":["OPERATOR_UNSPECIFIED","OPERATOR_EQUALS","OPERATOR_GREATER_THAN","OPERATOR_GREATER_THAN_OR_EQUAL","OPERATOR_LESS_THAN","OPERATOR_LESS_THAN_OR_EQUAL"],"default":"OPERATOR_UNSPECIFIED"},"value":{"type":"string","description":"value is used by the comparator."}},"title":"Condition describes the condition that must be validated by the"},"description":"conditions are the conditions that should be matched by the data to be\nconsidered of interest."}},"description":"Filter describes the conditions under which an oracle data is considered of\ninterest or not."},"description":"filters describes which oracle data are considered of interest or not for\nthe product (or the risk model)."}},"description":"An oracle spec describe the oracle data that a product (or a risk model)\nwants to get from the oracle engine."},"oracleSpecBinding":{"title":"The binding between the oracle spec and the settlement price","type":"object","properties":{"settlementPriceProperty":{"type":"string","description":"settlement_price_property holds the name of the property in the oracle data\nthat should be used as settlement price.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement price."},"tradingTerminationProperty":{"type":"string","title":"the name of the property in the oracle data that signals termination of trading"}}},"settlementDataDecimals":{"type":"integer","format":"int64","title":"The number of decimal places implied by the settlement data (such as price) emitted by the settlement oracle"}}}}},"decimalPlaces":{"type":"string","format":"uint64","title":"Decimal places used for the new market, sets the smallest price increment on the book"},"metadata":{"type":"array","items":{"type":"string"},"title":"Optional new market meta data, tags"},"priceMonitoringParameters":{"title":"Price monitoring parameters","type":"object","properties":{"triggers":{"type":"array","items":{"type":"object","properties":{"horizon":{"type":"string","format":"int64","title":"Price monitoring projection horizon τ in seconds"},"probability":{"type":"string","title":"Price monitoring probability level p"},"auctionExtension":{"type":"string","format":"int64","title":"Price monitoring auction extension duration in seconds should the price\nbreach it's theoretical level over the specified horizon at the specified\nprobability level"}},"title":"PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration"}}}},"liquidityMonitoringParameters":{"title":"Liquidity monitoring parameters","type":"object","properties":{"targetStakeParameters":{"title":"Specifies parameters related to target stake calculation","type":"object","properties":{"timeWindow":{"type":"string","format":"int64","title":"Specifies length of time window expressed in seconds for target stake calculation"},"scalingFactor":{"type":"number","format":"double","title":"Specifies scaling factors used in target stake calculation"}}},"triggeringRatio":{"type":"number","format":"double","title":"Specifies the triggering ratio for entering liquidity auction"},"auctionExtension":{"type":"string","format":"int64","title":"Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction"}}},"simple":{"title":"Simple risk model parameters, valid only if MODEL_SIMPLE is selected","type":"object","properties":{"factorLong":{"type":"number","format":"double","title":"Pre-defined risk factor value for long"},"factorShort":{"type":"number","format":"double","title":"Pre-defined risk factor value for short"},"maxMoveUp":{"type":"number","format":"double","title":"Pre-defined maximum price move up that the model considers as valid"},"minMoveDown":{"type":"number","format":"double","title":"Pre-defined minimum price move down that the model considers as valid"},"probabilityOfTrading":{"type":"number","format":"double","title":"Pre-defined constant probability of trading"}}},"logNormal":{"title":"Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected","type":"object","properties":{"riskAversionParameter":{"type":"number","format":"double","title":"Risk Aversion Parameter"},"tau":{"type":"number","format":"double","title":"Tau"},"params":{"title":"Risk model parameters for log normal","type":"object","properties":{"mu":{"type":"number","format":"double","title":"Mu param"},"r":{"type":"number","format":"double","title":"R param"},"sigma":{"type":"number","format":"double","title":"Sigma param"}}}}},"positionDecimalPlaces":{"type":"string","format":"uint64","title":"Decimal places for order sizes, sets what size the smallest order / position on the market can be"}}}}},"updateNetworkParameter":{"title":"Proposal change for updating Vega network parameters","type":"object","properties":{"changes":{"title":"The network parameter to update","type":"object","properties":{"key":{"type":"string","title":"The unique key"},"value":{"type":"string","title":"The value for the network parameter"}}}}},"newAsset":{"title":"Proposal change for creating new assets on Vega","type":"object","properties":{"changes":{"title":"The configuration of the new asset","type":"object","properties":{"name":{"type":"string","title":"Name of the asset (e.g: Great British Pound)"},"symbol":{"type":"string","title":"Symbol of the asset (e.g: GBP)"},"decimals":{"type":"string","format":"uint64","title":"Number of decimal / precision handled by this asset"},"quantum":{"type":"string","title":"The minimum economically meaningful amount in the asset"},"builtinAsset":{"title":"A built-in asset","type":"object","properties":{"maxFaucetAmountMint":{"type":"string","title":"Maximum amount that can be requested by a party through the built-in asset faucet at a time"}}},"erc20":{"title":"An Ethereum ERC20 asset","type":"object","properties":{"contractAddress":{"type":"string","title":"The address of the contract for the token, on the ethereum network"},"lifetimeLimit":{"type":"string","title":"The lifetime limits deposit per address\nnote: this is a temporary measure for restricted mainnet"},"withdrawThreshold":{"type":"string","title":"The maximum allowed per withdraw\nnote: this is a temporary measure for restricted mainnet"}}}}}}},"newFreeform":{"title":"Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,\nand can be used to gauge community sentiment","type":"object","description":"Freeform proposal\nThis message is just used as a placeholder to sort out the nature of the\nproposal once parsed."},"updateAsset":{"title":"Proposal change for updating an asset","type":"object","properties":{"assetId":{"type":"string","title":"The ID of the asset to be updated"},"changes":{"title":"The changes to apply on an existing asset","type":"object","properties":{"quantum":{"type":"string","title":"The minimum economically meaningful amount in the asset"},"erc20":{"title":"An Ethereum ERC20 asset","type":"object","properties":{"lifetimeLimit":{"type":"string","title":"The lifetime limits deposit per address.\nThis is will be interpreted against the asset decimals.\nnote: this is a temporary measure for restricted mainnet"},"withdrawThreshold":{"type":"string","title":"The maximum allowed per withdraw.\nThis is will be interpreted against the asset decimals.\nnote: this is a temporary measure for restricted mainnet"}}}},"description":"The changes to apply on an existing asset."}}}}},"rationale":{"description":"The rationale behind a proposal.","type":"object","properties":{"description":{"type":"string","description":"Description to show a short title / something in case the link goes offline.\nThis is to be between 0 and 20k unicode characters.\nThis is mandatory for all proposals."},"title":{"type":"string","description":"Title to be used to give a short description of the proposal in lists.\nThis is to be between 0 and 100 unicode characters.\nThis is mandatory for all proposals."}}}},"title":"A command to submit a new proposal for the\nVega network governance"},"voteSubmission":{"type":"object","properties":{"proposalId":{"type":"string","description":"The ID of the proposal to vote for."},"value":{"title":"The actual value of the vote","type":"string","enum":["VALUE_UNSPECIFIED","VALUE_NO","VALUE_YES"],"default":"VALUE_UNSPECIFIED","description":"- VALUE_UNSPECIFIED: Default value, always invalid\n - VALUE_NO: A vote against the proposal\n - VALUE_YES: A vote in favour of the proposal"}},"description":"A command to submit a new vote for a governance\nproposal."},"liquidityProvisionSubmission":{"type":"object","properties":{"marketId":{"type":"string","title":"Market identifier for the order, required field"},"commitmentAmount":{"type":"string","title":"Specified as a unitless number that represents the amount of settlement asset of the market"},"fee":{"type":"string","title":"Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers"},"sells":{"type":"array","items":{"type":"object","properties":{"reference":{"title":"The pegged reference point for the order","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"},"proportion":{"type":"integer","format":"int64","title":"The relative proportion of the commitment to be allocated at a price level"},"offset":{"type":"string","title":"The offset/amount of units away for the order"}},"title":"Represents a liquidity order"},"title":"A set of liquidity sell orders to meet the liquidity provision obligation"},"buys":{"type":"array","items":{"type":"object","properties":{"reference":{"title":"The pegged reference point for the order","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"},"proportion":{"type":"integer","format":"int64","title":"The relative proportion of the commitment to be allocated at a price level"},"offset":{"type":"string","title":"The offset/amount of units away for the order"}},"title":"Represents a liquidity order"},"title":"A set of liquidity buy orders to meet the liquidity provision obligation"},"reference":{"type":"string","title":"A reference to be added to every order created out of this liquidityProvisionSubmission"}},"title":"A liquidity provision submitted for a given market"},"delegateSubmission":{"type":"object","properties":{"nodeId":{"type":"string","title":"The ID for the node to delegate to"},"amount":{"type":"string","title":"The amount of stake to delegate"}},"title":"A command to submit an instruction to delegate some stake to a node"},"undelegateSubmission":{"type":"object","properties":{"nodeId":{"type":"string"},"amount":{"type":"string","title":"optional, if not specified = ALL"},"method":{"type":"string","enum":["METHOD_UNSPECIFIED","METHOD_NOW","METHOD_AT_END_OF_EPOCH","METHOD_IN_ANGER"],"default":"METHOD_UNSPECIFIED"}}},"liquidityProvisionCancellation":{"type":"object","properties":{"marketId":{"type":"string"}},"title":"Cancel a liquidity provision request"},"liquidityProvisionAmendment":{"type":"object","properties":{"marketId":{"type":"string"},"commitmentAmount":{"type":"string","title":"From here at least one of the following is required to consider the command valid"},"fee":{"type":"string"},"sells":{"type":"array","items":{"type":"object","properties":{"reference":{"title":"The pegged reference point for the order","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"},"proportion":{"type":"integer","format":"int64","title":"The relative proportion of the commitment to be allocated at a price level"},"offset":{"type":"string","title":"The offset/amount of units away for the order"}},"title":"Represents a liquidity order"}},"buys":{"type":"array","items":{"type":"object","properties":{"reference":{"title":"The pegged reference point for the order","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"},"proportion":{"type":"integer","format":"int64","title":"The relative proportion of the commitment to be allocated at a price level"},"offset":{"type":"string","title":"The offset/amount of units away for the order"}},"title":"Represents a liquidity order"}},"reference":{"type":"string"}},"title":"Amend a liquidity provision request"},"transfer":{"type":"object","properties":{"fromAccountType":{"title":"The account type from which the funds of the party\nshould be taken","type":"string","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS"],"default":"ACCOUNT_TYPE_UNSPECIFIED","description":"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nThe required initial margin is allocated to each market from your general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nThe Vega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold"},"to":{"type":"string","title":"The public key of the destination account"},"toAccountType":{"title":"The type of the destination account","type":"string","enum":["ACCOUNT_TYPE_UNSPECIFIED","ACCOUNT_TYPE_INSURANCE","ACCOUNT_TYPE_SETTLEMENT","ACCOUNT_TYPE_MARGIN","ACCOUNT_TYPE_GENERAL","ACCOUNT_TYPE_FEES_INFRASTRUCTURE","ACCOUNT_TYPE_FEES_LIQUIDITY","ACCOUNT_TYPE_FEES_MAKER","ACCOUNT_TYPE_BOND","ACCOUNT_TYPE_EXTERNAL","ACCOUNT_TYPE_GLOBAL_INSURANCE","ACCOUNT_TYPE_GLOBAL_REWARD","ACCOUNT_TYPE_PENDING_TRANSFERS","ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES","ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES","ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS"],"default":"ACCOUNT_TYPE_UNSPECIFIED","description":"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nThe required initial margin is allocated to each market from your general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nThe Vega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold"},"asset":{"type":"string","title":"The asset"},"amount":{"type":"string","title":"The amount to be taken from the source account"},"reference":{"type":"string","title":"The reference to be attached to the transfer"},"oneOff":{"type":"object","properties":{"deliverOn":{"type":"string","format":"int64","title":"A unix timestamp in second. Time at which the\ntransfer should be delivered in the to account"}},"title":"Specific details for a one off transfer"},"recurring":{"type":"object","properties":{"startEpoch":{"type":"string","format":"uint64","title":"The first epoch from which this transfer shall be paid"},"endEpoch":{"type":"string","format":"uint64","title":"The last epoch at which this transfer shall be paid"},"factor":{"type":"string","title":"factor needs to be > 0"},"dispatchStrategy":{"title":"optional parameter defining how a transfer is dispatched","type":"object","properties":{"assetForMetric":{"type":"string","title":"The asset to use for metric"},"metric":{"title":"The metric to apply","type":"string","enum":["DISPATCH_METRIC_UNSPECIFIED","DISPATCH_METRIC_MAKER_FEES_PAID","DISPATCH_METRIC_MAKER_FEES_RECEIVED","DISPATCH_METRIC_LP_FEES_RECEIVED","DISPATCH_METRIC_MARKET_VALUE"],"default":"DISPATCH_METRIC_UNSPECIFIED"},"markets":{"type":"array","items":{"type":"string"},"title":"Optional markets in scope"}}}},"title":"Specific details for a recurring transfer"}},"title":"A transfer initiated by a party"},"cancelTransfer":{"type":"object","properties":{"transferId":{"type":"string","title":"The ID of the transfer to cancel"}},"title":"A request for cancelling a recurring transfer"},"announceNode":{"type":"object","properties":{"vegaPubKey":{"type":"string","title":"Vega public key, required field"},"ethereumAddress":{"type":"string","title":"Ethereum public key, required field"},"chainPubKey":{"type":"string","title":"Public key for the blockchain, required field"},"infoUrl":{"type":"string","title":"URL with more info on the node"},"country":{"type":"string","title":"Country code (ISO 3166-1 alpha-2) for the location of the node"},"id":{"type":"string","title":"ID of the validator, (public master key)"},"name":{"type":"string","title":"Name of the validator"},"avatarUrl":{"type":"string","title":"AvatarURL of the validator"},"vegaPubKeyIndex":{"type":"integer","format":"int64","title":"Vega public key derivation index"},"fromEpoch":{"type":"string","format":"uint64","title":"The epoch from which the validator is expected\nto be ready to validate blocks"},"ethereumSignature":{"title":"Signature from the validator made using the ethereum wallet","type":"object","properties":{"value":{"type":"string","description":"The bytes of the signature (hex-encoded)."},"algo":{"type":"string","description":"The algorithm used to create the signature."},"version":{"type":"integer","format":"int64","description":"The version of the signature used to create the signature."}},"description":"A signature to authenticate a transaction and to be verified by the Vega\nnetwork."},"vegaSignature":{"title":"Signature from the validator made using the vega wallet","type":"object","properties":{"value":{"type":"string","description":"The bytes of the signature (hex-encoded)."},"algo":{"type":"string","description":"The algorithm used to create the signature."},"version":{"type":"integer","format":"int64","description":"The version of the signature used to create the signature."}},"description":"A signature to authenticate a transaction and to be verified by the Vega\nnetwork."},"submitterAddress":{"type":"string","title":"Ethereum public key to use as a submitter to allow automatic signature generation"}},"title":"Used announce a node as a new potential validator"},"batchMarketInstructions":{"type":"object","properties":{"cancellations":{"type":"array","items":{"type":"object","properties":{"orderId":{"type":"string","title":"Unique identifier for the order (set by the system after consensus), required field"},"marketId":{"type":"string","title":"Market identifier for the order, required field"}},"title":"An order cancellation is a request to cancel an existing order on Vega"},"title":"A list of order cancellations to be processed sequentially"},"amendments":{"type":"array","items":{"type":"object","properties":{"orderId":{"type":"string","title":"Order identifier, this is required to find the order and will not be updated, required field"},"marketId":{"type":"string","title":"Market identifier, this is required to find the order and will not be updated"},"price":{"type":"string","title":"Amend the price for the order, if the Price value is set, otherwise price will remain unchanged - See [`Price`](#vega.Price)"},"sizeDelta":{"type":"string","format":"int64","title":"Amend the size for the order by the delta specified:\n- To reduce the size from the current value set a negative integer value\n- To increase the size from the current value, set a positive integer value\n- To leave the size unchanged set a value of zero"},"expiresAt":{"type":"string","format":"int64","title":"Amend the expiry time for the order, if the Timestamp value is set, otherwise expiry time will remain unchanged\n- See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`"},"timeInForce":{"title":"Amend the time in force for the order, set to TIME_IN_FORCE_UNSPECIFIED to remain unchanged\n- See [`TimeInForce`](#api.VegaTimeResponse).`timestamp`","type":"string","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"default":"TIME_IN_FORCE_UNSPECIFIED","description":"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"},"peggedOffset":{"type":"string","title":"Amend the pegged order offset for the order"},"peggedReference":{"title":"Amend the pegged order reference for the order\n- See [`PeggedReference`](#vega.PeggedReference)","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"}},"title":"An order amendment is a request to amend or update an existing order on Vega"},"title":"A list of order amendments to be processed sequentially"},"submissions":{"type":"array","items":{"type":"object","properties":{"marketId":{"type":"string","title":"Market identifier for the order, required field"},"price":{"type":"string","title":"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\n, required field for limit orders, however it is not required for market orders"},"size":{"type":"string","format":"uint64","title":"Size for the order, for example, in a futures market the size equals the number of units, cannot be negative"},"side":{"title":"Side for the order, e.g. SIDE_BUY or SIDE_SELL, required field\n- See `Side`","type":"string","enum":["SIDE_UNSPECIFIED","SIDE_BUY","SIDE_SELL"],"default":"SIDE_UNSPECIFIED","description":"- SIDE_UNSPECIFIED: Default value, always invalid\n - SIDE_BUY: Buy order\n - SIDE_SELL: Sell order"},"timeInForce":{"title":"Time in force indicates how long an order will remain active before it is executed or expires, required field\n- See `Order.TimeInForce`","type":"string","enum":["TIME_IN_FORCE_UNSPECIFIED","TIME_IN_FORCE_GTC","TIME_IN_FORCE_GTT","TIME_IN_FORCE_IOC","TIME_IN_FORCE_FOK","TIME_IN_FORCE_GFA","TIME_IN_FORCE_GFN"],"default":"TIME_IN_FORCE_UNSPECIFIED","description":"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"},"expiresAt":{"type":"string","format":"int64","title":"Timestamp for when the order will expire, in nanoseconds since the epoch,\nrequired field only for `Order.TimeInForce`.TIME_IN_FORCE_GTT`\n- See `VegaTimeResponse`.`timestamp`"},"type":{"title":"Type for the order, required field - See `Order.Type`","type":"string","enum":["TYPE_UNSPECIFIED","TYPE_LIMIT","TYPE_MARKET","TYPE_NETWORK"],"default":"TYPE_UNSPECIFIED","description":"- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_LIMIT: Used for Limit orders\n - TYPE_MARKET: Used for Market orders\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)"},"reference":{"type":"string","title":"Reference given for the order, this is typically used to retrieve an order submitted through consensus, currently\nset internally by the node to return a unique reference identifier for the order submission"},"peggedOrder":{"title":"Used to specify the details for a pegged order\n- See `PeggedOrder`","type":"object","properties":{"reference":{"title":"The price point the order is linked to","type":"string","enum":["PEGGED_REFERENCE_UNSPECIFIED","PEGGED_REFERENCE_MID","PEGGED_REFERENCE_BEST_BID","PEGGED_REFERENCE_BEST_ASK"],"default":"PEGGED_REFERENCE_UNSPECIFIED","description":"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"},"offset":{"type":"string","title":"Offset from the price reference"}}}},"title":"An order submission is a request to submit or create a new order on Vega"},"title":"A list of order submissions to be processed sequentially"}},"title":"A batch of order instructions.\nThis command accepts only the following batches of commands\nand will be processed in the following order:\n- OrderCancellation\n- OrderAmendment\n- OrderSubmission\nThe total amount of commands in the batch across all three lists of\ninstructions is restricted by the following network parameter:\n\"spam.protection.max.batchSize\""},"nodeVote":{"title":"Validator commands","type":"object","properties":{"reference":{"type":"string","title":"Reference, required field"}}},"nodeSignature":{"type":"object","properties":{"id":{"type":"string","title":"The identifier of the resource being signed"},"sig":{"type":"string","format":"byte","title":"The signature"},"kind":{"title":"The kind of resource being signed","type":"string","enum":["NODE_SIGNATURE_KIND_UNSPECIFIED","NODE_SIGNATURE_KIND_ASSET_NEW","NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED","NODE_SIGNATURE_KIND_ASSET_UPDATE"],"default":"NODE_SIGNATURE_KIND_UNSPECIFIED","description":"- NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input\n - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing\n - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing"}},"title":"Represents a signature from a validator, to be used by a foreign chain in order to recognise a decision taken by the Vega network"},"chainEvent":{"type":"object","properties":{"txId":{"type":"string","title":"The identifier of the transaction in which the events happened, usually a hash"},"nonce":{"type":"string","format":"uint64","title":"Arbitrary one-time integer used to prevent replay attacks"},"builtin":{"title":"Built-in asset event","type":"object","properties":{"deposit":{"title":"Built-in asset deposit","type":"object","properties":{"vegaAssetId":{"type":"string","title":"A Vega network internal asset identifier"},"partyId":{"type":"string","title":"A Vega party identifier (pub-key)"},"amount":{"type":"string","title":"The amount to be deposited"}}},"withdrawal":{"title":"Built-in asset withdrawal","type":"object","properties":{"vegaAssetId":{"type":"string","title":"A Vega network internal asset identifier"},"partyId":{"type":"string","title":"A Vega network party identifier (pub-key)"},"amount":{"type":"string","title":"The amount to be withdrawn"}}}}},"erc20":{"title":"Ethereum ERC20 event","type":"object","properties":{"index":{"type":"string","format":"uint64","title":"Index of the log in the transaction"},"block":{"type":"string","format":"uint64","title":"The block in which the transaction was added"},"assetList":{"title":"List an ERC20 asset","type":"object","properties":{"vegaAssetId":{"type":"string","title":"The Vega network internal identifier of the asset"},"assetSource":{"type":"string","title":"The ethereum address of the asset"}}},"assetDelist":{"title":"De-list an ERC20 asset","type":"object","properties":{"vegaAssetId":{"type":"string","title":"The Vega network internal identifier of the asset"}}},"deposit":{"title":"Deposit ERC20 asset","type":"object","properties":{"vegaAssetId":{"type":"string","title":"The vega network internal identifier of the asset"},"sourceEthereumAddress":{"type":"string","title":"The Ethereum wallet that initiated the deposit"},"targetPartyId":{"type":"string","title":"The Vega party identifier (pub-key) which is the target of the deposit"},"amount":{"type":"string","title":"The amount to be deposited"}}},"withdrawal":{"title":"Withdraw ERC20 asset","type":"object","properties":{"vegaAssetId":{"type":"string","title":"The Vega network internal identifier of the asset"},"targetEthereumAddress":{"type":"string","title":"The target Ethereum wallet address"},"referenceNonce":{"type":"string","title":"The reference nonce used for the transaction"}}},"assetLimitsUpdated":{"title":"Update an ERC20 asset","type":"object","properties":{"vegaAssetId":{"type":"string","title":"The Vega network internal identifier of the asset"},"sourceEthereumAddress":{"type":"string","title":"The Ethereum wallet that initiated the deposit"},"lifetimeLimits":{"type":"string","title":"The updated lifetime limits"},"withdrawThreshold":{"type":"string","title":"The updated withdraw threshold"}}},"bridgeStopped":{"type":"boolean","title":"Bridge operations has been stopped"},"bridgeResumed":{"type":"boolean","title":"Bridge operations has been resumed"}}},"stakingEvent":{"title":"Ethereum Staking event","type":"object","properties":{"index":{"type":"string","format":"uint64","title":"Index of the log in the transaction"},"block":{"type":"string","format":"uint64","title":"The block in which the transaction was added"},"stakeDeposited":{"type":"object","properties":{"ethereumAddress":{"type":"string","title":"Ethereum Address of the user depositing stake (hex encode with 0x prefix)"},"vegaPublicKey":{"type":"string","title":"The public of the party receiving the stake deposit (hex encode)"},"amount":{"type":"string","title":"The amount deposited (base 10)"},"blockTime":{"type":"string","format":"int64","description":"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake started to be available."}}},"stakeRemoved":{"type":"object","properties":{"ethereumAddress":{"type":"string","title":"Ethereum address of the user removing stake (hex encode with 0x prefix)"},"vegaPublicKey":{"type":"string","title":"The public key of the party from which to remove stake (hex encode)"},"amount":{"type":"string","title":"The amount removed (base 10)"},"blockTime":{"type":"string","format":"int64","description":"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."}}},"totalSupply":{"type":"object","properties":{"tokenAddress":{"type":"string","title":"The address of the staking asset"},"totalSupply":{"type":"string","title":"The total supply observed for the token"}}}}},"erc20Multisig":{"title":"Ethereum ERC20 multisig event","type":"object","properties":{"index":{"type":"string","format":"uint64","title":"Index of the log in the transaction"},"block":{"type":"string","format":"uint64","title":"The block in which the transaction was added"},"signerAdded":{"title":"Add a signer to the erc20 bridge","type":"object","properties":{"newSigner":{"type":"string","title":"The ethereum address of the new signer"},"nonce":{"type":"string","title":"The nonce create by the vega network used for this new signer"},"blockTime":{"type":"string","format":"int64","description":"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."}}},"signerRemoved":{"title":"Remove a signer from the erc20 bridge","type":"object","properties":{"oldSigner":{"type":"string","title":"The ethereum address of the old signer"},"nonce":{"type":"string","title":"The nonce create by the vega network used for this old signer"},"blockTime":{"type":"string","format":"int64","description":"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."}}},"thresholdSet":{"title":"Threshold set","type":"object","properties":{"newThreshold":{"type":"integer","format":"int64","title":"The new threshold"},"nonce":{"type":"string","title":"The nonce create by the vega network"},"blockTime":{"type":"string","format":"int64","description":"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."}}}}}},"title":"An event forwarded to the Vega network to provide information on events happening on other networks"},"keyRotateSubmission":{"type":"object","properties":{"newPubKeyIndex":{"type":"integer","format":"int64","title":"New Vega public key derivation index"},"targetBlock":{"type":"string","format":"uint64","title":"Target block at which the key rotation will take effect on"},"newPubKey":{"type":"string","title":"The new public key to rotate to"},"currentPubKeyHash":{"type":"string","title":"Hash of currently used public key"}},"title":"A transaction to allow validator to rotate their vega keys"},"stateVariableProposal":{"type":"object","properties":{"proposal":{"title":"The state value proposal details","type":"object","properties":{"stateVarId":{"type":"string","title":"state variable identifier"},"eventId":{"type":"string","title":"event identifier"},"kvb":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"tolerance":{"type":"string"},"value":{"type":"object","properties":{"scalarVal":{"type":"object","properties":{"value":{"type":"string"}}},"vectorVal":{"type":"object","properties":{"value":{"type":"array","items":{"type":"string"}}}},"matrixVal":{"type":"object","properties":{"value":{"type":"array","items":{"type":"object","properties":{"value":{"type":"array","items":{"type":"string"}}}}}}}}}}},"title":"key value tolerance triplets"}}}}},"validatorHeartbeat":{"type":"object","properties":{"nodeId":{"type":"string","title":"the id of the node emitting the heartbeat"},"ethereumSignature":{"title":"Signature from the validator made using the ethereum wallet","type":"object","properties":{"value":{"type":"string","description":"The bytes of the signature (hex-encoded)."},"algo":{"type":"string","description":"The algorithm used to create the signature."},"version":{"type":"integer","format":"int64","description":"The version of the signature used to create the signature."}},"description":"A signature to authenticate a transaction and to be verified by the Vega\nnetwork."},"vegaSignature":{"title":"Signature from the validator made using the vega wallet","type":"object","properties":{"value":{"type":"string","description":"The bytes of the signature (hex-encoded)."},"algo":{"type":"string","description":"The algorithm used to create the signature."},"version":{"type":"integer","format":"int64","description":"The version of the signature used to create the signature."}},"description":"A signature to authenticate a transaction and to be verified by the Vega\nnetwork."}},"title":"A message from a validator signaling they are still online and validating blocks\nor ready to validate block when they are till a potential validator"},"ethereumKeyRotateSubmission":{"type":"object","properties":{"targetBlock":{"type":"string","format":"uint64","title":"Target block at which the key rotation will take effect on"},"newAddress":{"type":"string","title":"The new adress to rotate to"},"currentAddress":{"type":"string","title":"Currently used public address"},"submitterAddress":{"type":"string","title":"Ethereum public key to use as a submitter to allow automatic signature generation"}},"title":"A transaction to allow validator to rotate their ethereum keys"},"protocolUpgradeProposal":{"type":"object","properties":{"upgradeBlockHeight":{"type":"string","format":"uint64","title":"The block height at which to perform the upgrade"},"vegaReleaseTag":{"type":"string","title":"the release tag for the vega binary"}}},"issueSignatures":{"type":"object","properties":{"submitter":{"type":"string","title":"The ethereum address which will submit the signatures to the smart-contract"},"kind":{"title":"The kind of signatures to generate, namely for whether a signer is being added or removed","type":"string","enum":["NODE_SIGNATURE_KIND_UNSPECIFIED","NODE_SIGNATURE_KIND_ASSET_NEW","NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED","NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED","NODE_SIGNATURE_KIND_ASSET_UPDATE"],"default":"NODE_SIGNATURE_KIND_UNSPECIFIED","description":"- NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input\n - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing\n - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing"},"validatorNodeId":{"type":"string","title":"The ID of the node that will be signed in or out of the smartcontract"}}},"oracleDataSubmission":{"title":"Oracles","type":"object","properties":{"source":{"title":"The source from which the data is coming from","type":"string","enum":["ORACLE_SOURCE_UNSPECIFIED","ORACLE_SOURCE_OPEN_ORACLE","ORACLE_SOURCE_JSON"],"default":"ORACLE_SOURCE_UNSPECIFIED","description":"- ORACLE_SOURCE_UNSPECIFIED: The default value\n - ORACLE_SOURCE_OPEN_ORACLE: Support for Open Oracle standard\n - ORACLE_SOURCE_JSON: Support for custom JSON data"},"payload":{"type":"string","format":"byte","title":"The data provided by the third party provider"}}}}}}}}}}}}},"default":{"description":"An unexpected error response.","content":{"application/json":{"schema":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"@type":{"type":"string"}},"additionalProperties":{}}}}}}}}},"parameters":[{"name":"limit","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"before","in":"query","required":false,"schema":{"type":"string"}},{"name":"after","in":"query","required":false,"schema":{"type":"string"}}],"tags":["BlockExplorerService"],"description":"BlockExplorerService_ListTransactions","method":"get","path":"/transactions","servers":[{"url":"https://api.n10.testnet.vega.xyz"}],"info":{"title":"blockexplorer/blockexplorer.proto","version":"version not set"},"postman":{"name":"Block Explorer Service List Transactions","description":{"type":"text/plain"},"url":{"path":["transactions"],"host":["{{baseUrl}}"],"query":[{"disabled":false,"key":"limit","value":""},{"disabled":false,"key":"before","value":""},{"disabled":false,"key":"after","value":""}],"variable":[]},"header":[{"key":"Accept","value":"application/json"}],"method":"GET"}}
sidebar_class_name: "get api-method"
info_path: docs/api/rest/explorer/blockexplorer-blockexplorer-proto
---

import ApiTabs from "@theme/ApiTabs";
import MimeTabs from "@theme/MimeTabs";
import ParamsItem from "@theme/ParamsItem";
import ResponseSamples from "@theme/ResponseSamples";
import SchemaItem from "@theme/SchemaItem"
import SchemaTabs from "@theme/SchemaTabs";
import DiscriminatorTabs from "@theme/DiscriminatorTabs";
import TabItem from "@theme/TabItem";

## BlockExplorerService_ListTransactions



BlockExplorerService_ListTransactions

<details style={{"marginBottom":"1rem"}} data-collapsed={false} open={true}><summary style={{}}><strong>Query Parameters</strong></summary><div><ul><ParamsItem className={"paramsItem"} param={{"name":"limit","in":"query","required":false,"schema":{"type":"integer","format":"int64"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"name":"before","in":"query","required":false,"schema":{"type":"string"}}}></ParamsItem><ParamsItem className={"paramsItem"} param={{"name":"after","in":"query","required":false,"schema":{"type":"string"}}}></ParamsItem></ul></div></details><div><ApiTabs><TabItem label={"200"} value={"200"}><div>

A successful response.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>transactions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"block"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"index"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"hash"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"submitter"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"code"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"cursor"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>command</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"nonce"} required={false} schemaDescription={"A number to provide uniqueness to prevent accidental replays and,\nin combination with `block_height`, deliberate attacks.\nA nonce provides uniqueness for otherwise identical transactions,\nensuring that the transaction hash uniquely identifies a specific transaction.\nGranted all other fields are equal, the nonce can either be a counter\nor generated at random to submit multiple transactions within the same\nblock (see below), without being identified as replays.\nPlease note that Protocol Buffers do not have a canonical, unique encoding\nand therefore different libraries or binaries may encode the same message\nslightly differently, causing a different hash."} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"blockHeight"} required={false} schemaDescription={"The block height at which the transaction was made.\nThis should be the current block height. The transaction will be valid\nfrom the block and up to the `tolerance` block height.\nExample: If the network has a tolerance of 150 blocks and `block_height`\nis set to `200`, then the transaction will be valid until block `350`.\nNote that a `block_height` that is ahead of the real block height will be\nrejected. The tolerance can be queried from the chain's network parameters.\n`block_height` prevents replay attacks in conjunction with `nonce` (see above)."} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"Market identifier for the order, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaDescription={undefined} schemaName={"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\n, required field for limit orders, however it is not required for market orders"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaDescription={"- SIDE_UNSPECIFIED: Default value, always invalid\n - SIDE_BUY: Buy order\n - SIDE_SELL: Sell order"} schemaName={"Side for the order, e.g. SIDE_BUY or SIDE_SELL, required field\n- See `Side`"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} defaultValue={"SIDE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaDescription={"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"} schemaName={"Time in force indicates how long an order will remain active before it is executed or expires, required field\n- See `Order.TimeInForce`"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} defaultValue={"TIME_IN_FORCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={"- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_LIMIT: Used for Limit orders\n - TYPE_MARKET: Used for Market orders\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)"} schemaName={"Type for the order, required field - See `Order.Type`"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} defaultValue={"TYPE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={undefined} schemaName={"Reference given for the order, this is typically used to retrieve an order submitted through consensus, currently\nset internally by the node to return a unique reference identifier for the order submission"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"The price point the order is linked to"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"offset"} required={false} schemaDescription={undefined} schemaName={"Offset from the price reference"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderCancellation</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"orderId"} required={false} schemaDescription={undefined} schemaName={"Unique identifier for the order (set by the system after consensus), required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"Market identifier for the order, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>orderAmendment</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"orderId"} required={false} schemaDescription={undefined} schemaName={"Order identifier, this is required to find the order and will not be updated, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"Market identifier, this is required to find the order and will not be updated"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaDescription={undefined} schemaName={"Amend the price for the order, if the Price value is set, otherwise price will remain unchanged - See [`Price`](#vega.Price)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"sizeDelta"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaDescription={"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"} schemaName={"Amend the time in force for the order, set to TIME_IN_FORCE_UNSPECIFIED to remain unchanged\n- See [`TimeInForce`](#api.VegaTimeResponse).`timestamp`"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} defaultValue={"TIME_IN_FORCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"peggedOffset"} required={false} schemaDescription={undefined} schemaName={"Amend the pegged order offset for the order"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"peggedReference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"Amend the pegged order reference for the order\n- See [`PeggedReference`](#vega.PeggedReference)"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>withdrawSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount to be withdrawn"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"asset"} required={false} schemaDescription={undefined} schemaName={"The asset to be withdrawn"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ext</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"receiverAddress"} required={false} schemaDescription={undefined} schemaName={"The address into which the bridge will release the funds"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>proposalSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={undefined} schemaName={"Proposal reference"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>terms</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"closingTimestamp"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"enactmentTimestamp"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"validationTimestamp"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateMarket</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"The identifier of the market to update"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>instrument</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"code"} required={false} schemaDescription={undefined} schemaName={"Instrument code, human-readable shortcode used to describe the instrument"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>future</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaDescription={undefined} schemaName={"Human-readable name/abbreviation of the quote name"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleSpecForSettlementPrice</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

An oracle spec describe the oracle data that a product (or a risk model)
wants to get from the oracle engine.

</div><SchemaItem collapsible={false} name={"pubKeys"} required={false} schemaDescription={"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

filters describes which oracle data are considered of interest or not for
the product (or the risk model).

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

key is the oracle data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={"name is the name of the property."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={"type is the type of the property."} schemaName={"string"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} defaultValue={"TYPE_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

conditions are the conditions that should be matched by the data to be
considered of interest.

</div><SchemaItem collapsible={false} name={"operator"} required={false} schemaDescription={"comparator is the type of comparison to make on the value."} schemaName={"string"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} defaultValue={"OPERATOR_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"value is used by the comparator."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleSpecForTradingTermination</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

An oracle spec describe the oracle data that a product (or a risk model)
wants to get from the oracle engine.

</div><SchemaItem collapsible={false} name={"pubKeys"} required={false} schemaDescription={"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

filters describes which oracle data are considered of interest or not for
the product (or the risk model).

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

key is the oracle data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={"name is the name of the property."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={"type is the type of the property."} schemaName={"string"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} defaultValue={"TYPE_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

conditions are the conditions that should be matched by the data to be
considered of interest.

</div><SchemaItem collapsible={false} name={"operator"} required={false} schemaDescription={"comparator is the type of comparison to make on the value."} schemaName={"string"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} defaultValue={"OPERATOR_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"value is used by the comparator."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"settlementPriceProperty"} required={false} schemaDescription={"settlement_price_property holds the name of the property in the oracle data\nthat should be used as settlement price.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement price."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"tradingTerminationProperty"} required={false} schemaDescription={undefined} schemaName={"the name of the property in the oracle data that signals termination of trading"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"settlementDataDecimals"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"metadata"} required={false} schemaDescription={undefined} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>priceMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"horizon"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"probability"} required={false} schemaDescription={undefined} schemaName={"Price monitoring probability level p"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>targetStakeParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"timeWindow"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"scalingFactor"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"triggeringRatio"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>simple</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"factorLong"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"factorShort"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"maxMoveUp"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"minMoveDown"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"probabilityOfTrading"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>logNormal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"riskAversionParameter"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"tau"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>params</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"mu"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"r"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"sigma"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>newMarket</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>instrument</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={undefined} schemaName={"Instrument name"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"code"} required={false} schemaDescription={undefined} schemaName={"Instrument code, human-readable shortcode used to describe the instrument"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>future</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"settlementAsset"} required={false} schemaDescription={undefined} schemaName={"Asset ID for the product's settlement asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"quoteName"} required={false} schemaDescription={undefined} schemaName={"Product quote name"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleSpecForSettlementPrice</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

An oracle spec describe the oracle data that a product (or a risk model)
wants to get from the oracle engine.

</div><SchemaItem collapsible={false} name={"pubKeys"} required={false} schemaDescription={"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

filters describes which oracle data are considered of interest or not for
the product (or the risk model).

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

key is the oracle data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={"name is the name of the property."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={"type is the type of the property."} schemaName={"string"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} defaultValue={"TYPE_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

conditions are the conditions that should be matched by the data to be
considered of interest.

</div><SchemaItem collapsible={false} name={"operator"} required={false} schemaDescription={"comparator is the type of comparison to make on the value."} schemaName={"string"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} defaultValue={"OPERATOR_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"value is used by the comparator."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleSpecForTradingTermination</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

An oracle spec describe the oracle data that a product (or a risk model)
wants to get from the oracle engine.

</div><SchemaItem collapsible={false} name={"pubKeys"} required={false} schemaDescription={"pubKeys is the list of authorized public keys that signed the data for this\noracle. All the public keys in the oracle data should be contained in these\npublic keys."} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>filters</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

filters describes which oracle data are considered of interest or not for
the product (or the risk model).

</div><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>key</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

key is the oracle data property key targeted by the filter.

</div><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={"name is the name of the property."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={"type is the type of the property."} schemaName={"string"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_EMPTY`, `TYPE_INTEGER`, `TYPE_STRING`, `TYPE_BOOLEAN`, `TYPE_DECIMAL`, `TYPE_TIMESTAMP`]"} defaultValue={"TYPE_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>conditions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

conditions are the conditions that should be matched by the data to be
considered of interest.

</div><SchemaItem collapsible={false} name={"operator"} required={false} schemaDescription={"comparator is the type of comparison to make on the value."} schemaName={"string"} qualifierMessage={"**Possible values:** [`OPERATOR_UNSPECIFIED`, `OPERATOR_EQUALS`, `OPERATOR_GREATER_THAN`, `OPERATOR_GREATER_THAN_OR_EQUAL`, `OPERATOR_LESS_THAN`, `OPERATOR_LESS_THAN_OR_EQUAL`]"} defaultValue={"OPERATOR_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"value is used by the comparator."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleSpecBinding</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"settlementPriceProperty"} required={false} schemaDescription={"settlement_price_property holds the name of the property in the oracle data\nthat should be used as settlement price.\nIf it is set to \"prices.BTC.value\", then the Future will use the value of\nthis property as settlement price."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"tradingTerminationProperty"} required={false} schemaDescription={undefined} schemaName={"the name of the property in the oracle data that signals termination of trading"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"settlementDataDecimals"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"decimalPlaces"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"metadata"} required={false} schemaDescription={undefined} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>priceMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>triggers</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"horizon"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"probability"} required={false} schemaDescription={undefined} schemaName={"Price monitoring probability level p"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityMonitoringParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>targetStakeParameters</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"timeWindow"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"scalingFactor"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"triggeringRatio"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"auctionExtension"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>simple</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"factorLong"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"factorShort"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"maxMoveUp"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"minMoveDown"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"probabilityOfTrading"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>logNormal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"riskAversionParameter"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"tau"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>params</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"mu"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"r"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"sigma"} required={false} schemaDescription={undefined} schemaName={"double"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"positionDecimalPlaces"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateNetworkParameter</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"key"} required={false} schemaDescription={undefined} schemaName={"The unique key"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={undefined} schemaName={"The value for the network parameter"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>newAsset</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={undefined} schemaName={"Name of the asset (e.g: Great British Pound)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"symbol"} required={false} schemaDescription={undefined} schemaName={"Symbol of the asset (e.g: GBP)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"decimals"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"quantum"} required={false} schemaDescription={undefined} schemaName={"The minimum economically meaningful amount in the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>builtinAsset</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"maxFaucetAmountMint"} required={false} schemaDescription={undefined} schemaName={"Maximum amount that can be requested by a party through the built-in asset faucet at a time"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"contractAddress"} required={false} schemaDescription={undefined} schemaName={"The address of the contract for the token, on the ethereum network"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"lifetimeLimit"} required={false} schemaDescription={undefined} schemaName={"The lifetime limits deposit per address\nnote: this is a temporary measure for restricted mainnet"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"withdrawThreshold"} required={false} schemaDescription={undefined} schemaName={"The maximum allowed per withdraw\nnote: this is a temporary measure for restricted mainnet"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"newFreeform"} required={false} schemaDescription={"Freeform proposal\nThis message is just used as a placeholder to sort out the nature of the\nproposal once parsed."} schemaName={"object"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>updateAsset</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"assetId"} required={false} schemaDescription={undefined} schemaName={"The ID of the asset to be updated"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>changes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The changes to apply on an existing asset.

</div><SchemaItem collapsible={false} name={"quantum"} required={false} schemaDescription={undefined} schemaName={"The minimum economically meaningful amount in the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"lifetimeLimit"} required={false} schemaDescription={undefined} schemaName={"The lifetime limits deposit per address.\nThis is will be interpreted against the asset decimals.\nnote: this is a temporary measure for restricted mainnet"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"withdrawThreshold"} required={false} schemaDescription={undefined} schemaName={"The maximum allowed per withdraw.\nThis is will be interpreted against the asset decimals.\nnote: this is a temporary measure for restricted mainnet"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>rationale</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

The rationale behind a proposal.

</div><SchemaItem collapsible={false} name={"description"} required={false} schemaDescription={"Description to show a short title / something in case the link goes offline.\nThis is to be between 0 and 20k unicode characters.\nThis is mandatory for all proposals."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"title"} required={false} schemaDescription={"Title to be used to give a short description of the proposal in lists.\nThis is to be between 0 and 100 unicode characters.\nThis is mandatory for all proposals."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>voteSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A command to submit a new vote for a governance
proposal.

</div><SchemaItem collapsible={false} name={"proposalId"} required={false} schemaDescription={"The ID of the proposal to vote for."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"- VALUE_UNSPECIFIED: Default value, always invalid\n - VALUE_NO: A vote against the proposal\n - VALUE_YES: A vote in favour of the proposal"} schemaName={"The actual value of the vote"} qualifierMessage={"**Possible values:** [`VALUE_UNSPECIFIED`, `VALUE_NO`, `VALUE_YES`]"} defaultValue={"VALUE_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityProvisionSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"Market identifier for the order, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"commitmentAmount"} required={false} schemaDescription={undefined} schemaName={"Specified as a unitless number that represents the amount of settlement asset of the market"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"fee"} required={false} schemaDescription={undefined} schemaName={"Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>sells</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"The pegged reference point for the order"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"proportion"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"offset"} required={false} schemaDescription={undefined} schemaName={"The offset/amount of units away for the order"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>buys</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"The pegged reference point for the order"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"proportion"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"offset"} required={false} schemaDescription={undefined} schemaName={"The offset/amount of units away for the order"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={undefined} schemaName={"A reference to be added to every order created out of this liquidityProvisionSubmission"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>delegateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"nodeId"} required={false} schemaDescription={undefined} schemaName={"The ID for the node to delegate to"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount of stake to delegate"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>undelegateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"nodeId"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"optional, if not specified = ALL"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"method"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={"**Possible values:** [`METHOD_UNSPECIFIED`, `METHOD_NOW`, `METHOD_AT_END_OF_EPOCH`, `METHOD_IN_ANGER`]"} defaultValue={"METHOD_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityProvisionCancellation</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>liquidityProvisionAmendment</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"commitmentAmount"} required={false} schemaDescription={undefined} schemaName={"From here at least one of the following is required to consider the command valid"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"fee"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>sells</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"The pegged reference point for the order"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"proportion"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"offset"} required={false} schemaDescription={undefined} schemaName={"The offset/amount of units away for the order"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>buys</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"The pegged reference point for the order"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"proportion"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"offset"} required={false} schemaDescription={undefined} schemaName={"The offset/amount of units away for the order"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>transfer</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"fromAccountType"} required={false} schemaDescription={"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nThe required initial margin is allocated to each market from your general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nThe Vega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold"} schemaName={"The account type from which the funds of the party\nshould be taken"} qualifierMessage={"**Possible values:** [`ACCOUNT_TYPE_UNSPECIFIED`, `ACCOUNT_TYPE_INSURANCE`, `ACCOUNT_TYPE_SETTLEMENT`, `ACCOUNT_TYPE_MARGIN`, `ACCOUNT_TYPE_GENERAL`, `ACCOUNT_TYPE_FEES_INFRASTRUCTURE`, `ACCOUNT_TYPE_FEES_LIQUIDITY`, `ACCOUNT_TYPE_FEES_MAKER`, `ACCOUNT_TYPE_BOND`, `ACCOUNT_TYPE_EXTERNAL`, `ACCOUNT_TYPE_GLOBAL_INSURANCE`, `ACCOUNT_TYPE_GLOBAL_REWARD`, `ACCOUNT_TYPE_PENDING_TRANSFERS`, `ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES`, `ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS`]"} defaultValue={"ACCOUNT_TYPE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"to"} required={false} schemaDescription={undefined} schemaName={"The public key of the destination account"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"toAccountType"} required={false} schemaDescription={"- ACCOUNT_TYPE_UNSPECIFIED: Default value\n - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market\n - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market\n - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.\nEach party will have a margin account for each market they have traded in.\nThe required initial margin is allocated to each market from your general account.\nCollateral in the margin account can't be withdrawn or used as margin on another market until\nit is released back to the general account.\nThe Vega protocol uses an internal accounting system to segregate funds held as\nmargin from other funds to ensure they are never lost or 'double spent'\n\nMargin account funds will vary as margin requirements on positions change\n - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will\nhave multiple general accounts, one for each asset they want\nto trade with\n\nGeneral accounts are where funds are initially deposited or withdrawn from,\nit is also the account where funds are taken to fulfil fees and initial margin requirements\n - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega\n - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets\n - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book\nand are then matched with an incoming order to create a trade - These fees reward parties\nwho provide the best priced liquidity that actually allows trading to take place\n - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments\n - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)\n - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset\n - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset\n - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)\n - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers\n - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers\n - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers\n - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold"} schemaName={"The type of the destination account"} qualifierMessage={"**Possible values:** [`ACCOUNT_TYPE_UNSPECIFIED`, `ACCOUNT_TYPE_INSURANCE`, `ACCOUNT_TYPE_SETTLEMENT`, `ACCOUNT_TYPE_MARGIN`, `ACCOUNT_TYPE_GENERAL`, `ACCOUNT_TYPE_FEES_INFRASTRUCTURE`, `ACCOUNT_TYPE_FEES_LIQUIDITY`, `ACCOUNT_TYPE_FEES_MAKER`, `ACCOUNT_TYPE_BOND`, `ACCOUNT_TYPE_EXTERNAL`, `ACCOUNT_TYPE_GLOBAL_INSURANCE`, `ACCOUNT_TYPE_GLOBAL_REWARD`, `ACCOUNT_TYPE_PENDING_TRANSFERS`, `ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES`, `ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES`, `ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS`]"} defaultValue={"ACCOUNT_TYPE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"asset"} required={false} schemaDescription={undefined} schemaName={"The asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount to be taken from the source account"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={undefined} schemaName={"The reference to be attached to the transfer"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oneOff</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"deliverOn"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>recurring</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"startEpoch"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"endEpoch"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"factor"} required={false} schemaDescription={undefined} schemaName={"factor needs to be > 0"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>dispatchStrategy</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"assetForMetric"} required={false} schemaDescription={undefined} schemaName={"The asset to use for metric"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"metric"} required={false} schemaDescription={undefined} schemaName={"The metric to apply"} qualifierMessage={"**Possible values:** [`DISPATCH_METRIC_UNSPECIFIED`, `DISPATCH_METRIC_MAKER_FEES_PAID`, `DISPATCH_METRIC_MAKER_FEES_RECEIVED`, `DISPATCH_METRIC_LP_FEES_RECEIVED`, `DISPATCH_METRIC_MARKET_VALUE`]"} defaultValue={"DISPATCH_METRIC_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"markets"} required={false} schemaDescription={undefined} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>cancelTransfer</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"transferId"} required={false} schemaDescription={undefined} schemaName={"The ID of the transfer to cancel"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>announceNode</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaPubKey"} required={false} schemaDescription={undefined} schemaName={"Vega public key, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"ethereumAddress"} required={false} schemaDescription={undefined} schemaName={"Ethereum public key, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"chainPubKey"} required={false} schemaDescription={undefined} schemaName={"Public key for the blockchain, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"infoUrl"} required={false} schemaDescription={undefined} schemaName={"URL with more info on the node"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"country"} required={false} schemaDescription={undefined} schemaName={"Country code (ISO 3166-1 alpha-2) for the location of the node"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"id"} required={false} schemaDescription={undefined} schemaName={"ID of the validator, (public master key)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={undefined} schemaName={"Name of the validator"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"avatarUrl"} required={false} schemaDescription={undefined} schemaName={"AvatarURL of the validator"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"vegaPubKeyIndex"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"fromEpoch"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethereumSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A signature to authenticate a transaction and to be verified by the Vega
network.

</div><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"The bytes of the signature (hex-encoded)."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"algo"} required={false} schemaDescription={"The algorithm used to create the signature."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaDescription={"The version of the signature used to create the signature."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>vegaSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A signature to authenticate a transaction and to be verified by the Vega
network.

</div><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"The bytes of the signature (hex-encoded)."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"algo"} required={false} schemaDescription={"The algorithm used to create the signature."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaDescription={"The version of the signature used to create the signature."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"submitterAddress"} required={false} schemaDescription={undefined} schemaName={"Ethereum public key to use as a submitter to allow automatic signature generation"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>batchMarketInstructions</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>cancellations</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"orderId"} required={false} schemaDescription={undefined} schemaName={"Unique identifier for the order (set by the system after consensus), required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"Market identifier for the order, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>amendments</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"orderId"} required={false} schemaDescription={undefined} schemaName={"Order identifier, this is required to find the order and will not be updated, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"Market identifier, this is required to find the order and will not be updated"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaDescription={undefined} schemaName={"Amend the price for the order, if the Price value is set, otherwise price will remain unchanged - See [`Price`](#vega.Price)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"sizeDelta"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaDescription={"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"} schemaName={"Amend the time in force for the order, set to TIME_IN_FORCE_UNSPECIFIED to remain unchanged\n- See [`TimeInForce`](#api.VegaTimeResponse).`timestamp`"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} defaultValue={"TIME_IN_FORCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"peggedOffset"} required={false} schemaDescription={undefined} schemaName={"Amend the pegged order offset for the order"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"peggedReference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"Amend the pegged order reference for the order\n- See [`PeggedReference`](#vega.PeggedReference)"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>submissions</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"marketId"} required={false} schemaDescription={undefined} schemaName={"Market identifier for the order, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"price"} required={false} schemaDescription={undefined} schemaName={"Price for the order, the price is an integer, for example `123456` is a correctly\nformatted price of `1.23456` assuming market configured to 5 decimal places,\n, required field for limit orders, however it is not required for market orders"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"size"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"side"} required={false} schemaDescription={"- SIDE_UNSPECIFIED: Default value, always invalid\n - SIDE_BUY: Buy order\n - SIDE_SELL: Sell order"} schemaName={"Side for the order, e.g. SIDE_BUY or SIDE_SELL, required field\n- See `Side`"} qualifierMessage={"**Possible values:** [`SIDE_UNSPECIFIED`, `SIDE_BUY`, `SIDE_SELL`]"} defaultValue={"SIDE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"timeInForce"} required={false} schemaDescription={"- TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend\n - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible\nand remains on the book until it either trades completely or is cancelled\n - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible\nand remains on the book until it either trades completely, is cancelled, or expires at a set time\nNOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry\n - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible\nbut does not remain on the book (whether it trades or not)\n - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)\nor not at all, does not remain on the book if it doesn't trade\n - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period\n - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)"} schemaName={"Time in force indicates how long an order will remain active before it is executed or expires, required field\n- See `Order.TimeInForce`"} qualifierMessage={"**Possible values:** [`TIME_IN_FORCE_UNSPECIFIED`, `TIME_IN_FORCE_GTC`, `TIME_IN_FORCE_GTT`, `TIME_IN_FORCE_IOC`, `TIME_IN_FORCE_FOK`, `TIME_IN_FORCE_GFA`, `TIME_IN_FORCE_GFN`]"} defaultValue={"TIME_IN_FORCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"expiresAt"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={"- TYPE_UNSPECIFIED: Default value, always invalid\n - TYPE_LIMIT: Used for Limit orders\n - TYPE_MARKET: Used for Market orders\n - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)"} schemaName={"Type for the order, required field - See `Order.Type`"} qualifierMessage={"**Possible values:** [`TYPE_UNSPECIFIED`, `TYPE_LIMIT`, `TYPE_MARKET`, `TYPE_NETWORK`]"} defaultValue={"TYPE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={undefined} schemaName={"Reference given for the order, this is typically used to retrieve an order submitted through consensus, currently\nset internally by the node to return a unique reference identifier for the order submission"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>peggedOrder</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={"- PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given\n - PEGGED_REFERENCE_MID: Mid price reference\n - PEGGED_REFERENCE_BEST_BID: Best bid price reference\n - PEGGED_REFERENCE_BEST_ASK: Best ask price reference"} schemaName={"The price point the order is linked to"} qualifierMessage={"**Possible values:** [`PEGGED_REFERENCE_UNSPECIFIED`, `PEGGED_REFERENCE_MID`, `PEGGED_REFERENCE_BEST_BID`, `PEGGED_REFERENCE_BEST_ASK`]"} defaultValue={"PEGGED_REFERENCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"offset"} required={false} schemaDescription={undefined} schemaName={"Offset from the price reference"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>nodeVote</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"reference"} required={false} schemaDescription={undefined} schemaName={"Reference, required field"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>nodeSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"id"} required={false} schemaDescription={undefined} schemaName={"The identifier of the resource being signed"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"sig"} required={false} schemaDescription={undefined} schemaName={"byte"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"kind"} required={false} schemaDescription={"- NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input\n - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing\n - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing"} schemaName={"The kind of resource being signed"} qualifierMessage={"**Possible values:** [`NODE_SIGNATURE_KIND_UNSPECIFIED`, `NODE_SIGNATURE_KIND_ASSET_NEW`, `NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED`, `NODE_SIGNATURE_KIND_ASSET_UPDATE`]"} defaultValue={"NODE_SIGNATURE_KIND_UNSPECIFIED"}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>chainEvent</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"txId"} required={false} schemaDescription={undefined} schemaName={"The identifier of the transaction in which the events happened, usually a hash"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>builtin</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>deposit</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaDescription={undefined} schemaName={"A Vega network internal asset identifier"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"partyId"} required={false} schemaDescription={undefined} schemaName={"A Vega party identifier (pub-key)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount to be deposited"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>withdrawal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaDescription={undefined} schemaName={"A Vega network internal asset identifier"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"partyId"} required={false} schemaDescription={undefined} schemaName={"A Vega network party identifier (pub-key)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount to be withdrawn"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"index"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"block"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>assetList</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaDescription={undefined} schemaName={"The Vega network internal identifier of the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"assetSource"} required={false} schemaDescription={undefined} schemaName={"The ethereum address of the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>assetDelist</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaDescription={undefined} schemaName={"The Vega network internal identifier of the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>deposit</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaDescription={undefined} schemaName={"The vega network internal identifier of the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"sourceEthereumAddress"} required={false} schemaDescription={undefined} schemaName={"The Ethereum wallet that initiated the deposit"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"targetPartyId"} required={false} schemaDescription={undefined} schemaName={"The Vega party identifier (pub-key) which is the target of the deposit"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount to be deposited"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>withdrawal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaDescription={undefined} schemaName={"The Vega network internal identifier of the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"targetEthereumAddress"} required={false} schemaDescription={undefined} schemaName={"The target Ethereum wallet address"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"referenceNonce"} required={false} schemaDescription={undefined} schemaName={"The reference nonce used for the transaction"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>assetLimitsUpdated</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"vegaAssetId"} required={false} schemaDescription={undefined} schemaName={"The Vega network internal identifier of the asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"sourceEthereumAddress"} required={false} schemaDescription={undefined} schemaName={"The Ethereum wallet that initiated the deposit"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"lifetimeLimits"} required={false} schemaDescription={undefined} schemaName={"The updated lifetime limits"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"withdrawThreshold"} required={false} schemaDescription={undefined} schemaName={"The updated withdraw threshold"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={false} name={"bridgeStopped"} required={false} schemaDescription={undefined} schemaName={"Bridge operations has been stopped"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"bridgeResumed"} required={false} schemaDescription={undefined} schemaName={"Bridge operations has been resumed"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stakingEvent</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"index"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"block"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stakeDeposited</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"ethereumAddress"} required={false} schemaDescription={undefined} schemaName={"Ethereum Address of the user depositing stake (hex encode with 0x prefix)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"vegaPublicKey"} required={false} schemaDescription={undefined} schemaName={"The public of the party receiving the stake deposit (hex encode)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount deposited (base 10)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaDescription={"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake started to be available."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stakeRemoved</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"ethereumAddress"} required={false} schemaDescription={undefined} schemaName={"Ethereum address of the user removing stake (hex encode with 0x prefix)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"vegaPublicKey"} required={false} schemaDescription={undefined} schemaName={"The public key of the party from which to remove stake (hex encode)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"amount"} required={false} schemaDescription={undefined} schemaName={"The amount removed (base 10)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaDescription={"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>totalSupply</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"tokenAddress"} required={false} schemaDescription={undefined} schemaName={"The address of the staking asset"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"totalSupply"} required={false} schemaDescription={undefined} schemaName={"The total supply observed for the token"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>erc20Multisig</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"index"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"block"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signerAdded</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"newSigner"} required={false} schemaDescription={undefined} schemaName={"The ethereum address of the new signer"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaDescription={undefined} schemaName={"The nonce create by the vega network used for this new signer"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaDescription={"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>signerRemoved</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"oldSigner"} required={false} schemaDescription={undefined} schemaName={"The ethereum address of the old signer"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaDescription={undefined} schemaName={"The nonce create by the vega network used for this old signer"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaDescription={"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>thresholdSet</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"newThreshold"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"nonce"} required={false} schemaDescription={undefined} schemaName={"The nonce create by the vega network"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"blockTime"} required={false} schemaDescription={"The time at which the block was produced\nwill be used to inform the core at what time\nthe stake was made unavailable."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>keyRotateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"newPubKeyIndex"} required={false} schemaDescription={undefined} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"targetBlock"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"newPubKey"} required={false} schemaDescription={undefined} schemaName={"The new public key to rotate to"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"currentPubKeyHash"} required={false} schemaDescription={undefined} schemaName={"Hash of currently used public key"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>stateVariableProposal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>proposal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"stateVarId"} required={false} schemaDescription={undefined} schemaName={"state variable identifier"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"eventId"} required={false} schemaDescription={undefined} schemaName={"event identifier"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>kvb</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"key"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"tolerance"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>value</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>scalarVal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>vectorVal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={undefined} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>matrixVal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>value</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={undefined} schemaName={"string[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>validatorHeartbeat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"nodeId"} required={false} schemaDescription={undefined} schemaName={"the id of the node emitting the heartbeat"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethereumSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A signature to authenticate a transaction and to be verified by the Vega
network.

</div><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"The bytes of the signature (hex-encoded)."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"algo"} required={false} schemaDescription={"The algorithm used to create the signature."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaDescription={"The version of the signature used to create the signature."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>vegaSignature</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A signature to authenticate a transaction and to be verified by the Vega
network.

</div><SchemaItem collapsible={false} name={"value"} required={false} schemaDescription={"The bytes of the signature (hex-encoded)."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"algo"} required={false} schemaDescription={"The algorithm used to create the signature."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"version"} required={false} schemaDescription={"The version of the signature used to create the signature."} schemaName={"int64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>ethereumKeyRotateSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"targetBlock"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"newAddress"} required={false} schemaDescription={undefined} schemaName={"The new adress to rotate to"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"currentAddress"} required={false} schemaDescription={undefined} schemaName={"Currently used public address"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"submitterAddress"} required={false} schemaDescription={undefined} schemaName={"Ethereum public key to use as a submitter to allow automatic signature generation"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>protocolUpgradeProposal</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"upgradeBlockHeight"} required={false} schemaDescription={undefined} schemaName={"uint64"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"vegaReleaseTag"} required={false} schemaDescription={undefined} schemaName={"the release tag for the vega binary"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>issueSignatures</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"submitter"} required={false} schemaDescription={undefined} schemaName={"The ethereum address which will submit the signatures to the smart-contract"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"kind"} required={false} schemaDescription={"- NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input\n - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing\n - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract\n - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing"} schemaName={"The kind of signatures to generate, namely for whether a signer is being added or removed"} qualifierMessage={"**Possible values:** [`NODE_SIGNATURE_KIND_UNSPECIFIED`, `NODE_SIGNATURE_KIND_ASSET_NEW`, `NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED`, `NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED`, `NODE_SIGNATURE_KIND_ASSET_UPDATE`]"} defaultValue={"NODE_SIGNATURE_KIND_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"validatorNodeId"} required={false} schemaDescription={undefined} schemaName={"The ID of the node that will be signed in or out of the smartcontract"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>oracleDataSubmission</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"source"} required={false} schemaDescription={"- ORACLE_SOURCE_UNSPECIFIED: The default value\n - ORACLE_SOURCE_OPEN_ORACLE: Support for Open Oracle standard\n - ORACLE_SOURCE_JSON: Support for custom JSON data"} schemaName={"The source from which the data is coming from"} qualifierMessage={"**Possible values:** [`ORACLE_SOURCE_UNSPECIFIED`, `ORACLE_SOURCE_OPEN_ORACLE`, `ORACLE_SOURCE_JSON`]"} defaultValue={"ORACLE_SOURCE_UNSPECIFIED"}></SchemaItem><SchemaItem collapsible={false} name={"payload"} required={false} schemaDescription={undefined} schemaName={"byte"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></div></details></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"transactions\": [\n    {\n      \"block\": \"string\",\n      \"index\": 0,\n      \"hash\": \"string\",\n      \"submitter\": \"string\",\n      \"type\": \"string\",\n      \"code\": 0,\n      \"cursor\": \"string\",\n      \"command\": {\n        \"nonce\": \"string\",\n        \"blockHeight\": \"string\",\n        \"orderSubmission\": {\n          \"marketId\": \"string\",\n          \"price\": \"string\",\n          \"size\": \"string\",\n          \"side\": \"SIDE_UNSPECIFIED\",\n          \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n          \"expiresAt\": \"string\",\n          \"type\": \"TYPE_UNSPECIFIED\",\n          \"reference\": \"string\",\n          \"peggedOrder\": {\n            \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n            \"offset\": \"string\"\n          }\n        },\n        \"orderCancellation\": {\n          \"orderId\": \"string\",\n          \"marketId\": \"string\"\n        },\n        \"orderAmendment\": {\n          \"orderId\": \"string\",\n          \"marketId\": \"string\",\n          \"price\": \"string\",\n          \"sizeDelta\": \"string\",\n          \"expiresAt\": \"string\",\n          \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n          \"peggedOffset\": \"string\",\n          \"peggedReference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n        },\n        \"withdrawSubmission\": {\n          \"amount\": \"string\",\n          \"asset\": \"string\",\n          \"ext\": {\n            \"erc20\": {\n              \"receiverAddress\": \"string\"\n            }\n          }\n        },\n        \"proposalSubmission\": {\n          \"reference\": \"string\",\n          \"terms\": {\n            \"closingTimestamp\": \"string\",\n            \"enactmentTimestamp\": \"string\",\n            \"validationTimestamp\": \"string\",\n            \"updateMarket\": {\n              \"marketId\": \"string\",\n              \"changes\": {\n                \"instrument\": {\n                  \"code\": \"string\",\n                  \"future\": {\n                    \"quoteName\": \"string\",\n                    \"oracleSpecForSettlementPrice\": {\n                      \"pubKeys\": [\n                        \"string\"\n                      ],\n                      \"filters\": [\n                        {\n                          \"key\": {\n                            \"name\": \"string\",\n                            \"type\": \"TYPE_UNSPECIFIED\"\n                          },\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        }\n                      ]\n                    },\n                    \"oracleSpecForTradingTermination\": {\n                      \"pubKeys\": [\n                        \"string\"\n                      ],\n                      \"filters\": [\n                        {\n                          \"key\": {\n                            \"name\": \"string\",\n                            \"type\": \"TYPE_UNSPECIFIED\"\n                          },\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        }\n                      ]\n                    },\n                    \"oracleSpecBinding\": {\n                      \"settlementPriceProperty\": \"string\",\n                      \"tradingTerminationProperty\": \"string\"\n                    },\n                    \"settlementDataDecimals\": 0\n                  }\n                },\n                \"metadata\": [\n                  \"string\"\n                ],\n                \"priceMonitoringParameters\": {\n                  \"triggers\": [\n                    {\n                      \"horizon\": \"string\",\n                      \"probability\": \"string\",\n                      \"auctionExtension\": \"string\"\n                    }\n                  ]\n                },\n                \"liquidityMonitoringParameters\": {\n                  \"targetStakeParameters\": {\n                    \"timeWindow\": \"string\",\n                    \"scalingFactor\": 0\n                  },\n                  \"triggeringRatio\": 0,\n                  \"auctionExtension\": \"string\"\n                },\n                \"simple\": {\n                  \"factorLong\": 0,\n                  \"factorShort\": 0,\n                  \"maxMoveUp\": 0,\n                  \"minMoveDown\": 0,\n                  \"probabilityOfTrading\": 0\n                },\n                \"logNormal\": {\n                  \"riskAversionParameter\": 0,\n                  \"tau\": 0,\n                  \"params\": {\n                    \"mu\": 0,\n                    \"r\": 0,\n                    \"sigma\": 0\n                  }\n                }\n              }\n            },\n            \"newMarket\": {\n              \"changes\": {\n                \"instrument\": {\n                  \"name\": \"string\",\n                  \"code\": \"string\",\n                  \"future\": {\n                    \"settlementAsset\": \"string\",\n                    \"quoteName\": \"string\",\n                    \"oracleSpecForSettlementPrice\": {\n                      \"pubKeys\": [\n                        \"string\"\n                      ],\n                      \"filters\": [\n                        {\n                          \"key\": {\n                            \"name\": \"string\",\n                            \"type\": \"TYPE_UNSPECIFIED\"\n                          },\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        }\n                      ]\n                    },\n                    \"oracleSpecForTradingTermination\": {\n                      \"pubKeys\": [\n                        \"string\"\n                      ],\n                      \"filters\": [\n                        {\n                          \"key\": {\n                            \"name\": \"string\",\n                            \"type\": \"TYPE_UNSPECIFIED\"\n                          },\n                          \"conditions\": [\n                            {\n                              \"operator\": \"OPERATOR_UNSPECIFIED\",\n                              \"value\": \"string\"\n                            }\n                          ]\n                        }\n                      ]\n                    },\n                    \"oracleSpecBinding\": {\n                      \"settlementPriceProperty\": \"string\",\n                      \"tradingTerminationProperty\": \"string\"\n                    },\n                    \"settlementDataDecimals\": 0\n                  }\n                },\n                \"decimalPlaces\": \"string\",\n                \"metadata\": [\n                  \"string\"\n                ],\n                \"priceMonitoringParameters\": {\n                  \"triggers\": [\n                    {\n                      \"horizon\": \"string\",\n                      \"probability\": \"string\",\n                      \"auctionExtension\": \"string\"\n                    }\n                  ]\n                },\n                \"liquidityMonitoringParameters\": {\n                  \"targetStakeParameters\": {\n                    \"timeWindow\": \"string\",\n                    \"scalingFactor\": 0\n                  },\n                  \"triggeringRatio\": 0,\n                  \"auctionExtension\": \"string\"\n                },\n                \"simple\": {\n                  \"factorLong\": 0,\n                  \"factorShort\": 0,\n                  \"maxMoveUp\": 0,\n                  \"minMoveDown\": 0,\n                  \"probabilityOfTrading\": 0\n                },\n                \"logNormal\": {\n                  \"riskAversionParameter\": 0,\n                  \"tau\": 0,\n                  \"params\": {\n                    \"mu\": 0,\n                    \"r\": 0,\n                    \"sigma\": 0\n                  }\n                },\n                \"positionDecimalPlaces\": \"string\"\n              }\n            },\n            \"updateNetworkParameter\": {\n              \"changes\": {\n                \"key\": \"string\",\n                \"value\": \"string\"\n              }\n            },\n            \"newAsset\": {\n              \"changes\": {\n                \"name\": \"string\",\n                \"symbol\": \"string\",\n                \"decimals\": \"string\",\n                \"quantum\": \"string\",\n                \"builtinAsset\": {\n                  \"maxFaucetAmountMint\": \"string\"\n                },\n                \"erc20\": {\n                  \"contractAddress\": \"string\",\n                  \"lifetimeLimit\": \"string\",\n                  \"withdrawThreshold\": \"string\"\n                }\n              }\n            },\n            \"newFreeform\": {},\n            \"updateAsset\": {\n              \"assetId\": \"string\",\n              \"changes\": {\n                \"quantum\": \"string\",\n                \"erc20\": {\n                  \"lifetimeLimit\": \"string\",\n                  \"withdrawThreshold\": \"string\"\n                }\n              }\n            }\n          },\n          \"rationale\": {\n            \"description\": \"string\",\n            \"title\": \"string\"\n          }\n        },\n        \"voteSubmission\": {\n          \"proposalId\": \"string\",\n          \"value\": \"VALUE_UNSPECIFIED\"\n        },\n        \"liquidityProvisionSubmission\": {\n          \"marketId\": \"string\",\n          \"commitmentAmount\": \"string\",\n          \"fee\": \"string\",\n          \"sells\": [\n            {\n              \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n              \"proportion\": 0,\n              \"offset\": \"string\"\n            }\n          ],\n          \"buys\": [\n            {\n              \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n              \"proportion\": 0,\n              \"offset\": \"string\"\n            }\n          ],\n          \"reference\": \"string\"\n        },\n        \"delegateSubmission\": {\n          \"nodeId\": \"string\",\n          \"amount\": \"string\"\n        },\n        \"undelegateSubmission\": {\n          \"nodeId\": \"string\",\n          \"amount\": \"string\",\n          \"method\": \"METHOD_UNSPECIFIED\"\n        },\n        \"liquidityProvisionCancellation\": {\n          \"marketId\": \"string\"\n        },\n        \"liquidityProvisionAmendment\": {\n          \"marketId\": \"string\",\n          \"commitmentAmount\": \"string\",\n          \"fee\": \"string\",\n          \"sells\": [\n            {\n              \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n              \"proportion\": 0,\n              \"offset\": \"string\"\n            }\n          ],\n          \"buys\": [\n            {\n              \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n              \"proportion\": 0,\n              \"offset\": \"string\"\n            }\n          ],\n          \"reference\": \"string\"\n        },\n        \"transfer\": {\n          \"fromAccountType\": \"ACCOUNT_TYPE_UNSPECIFIED\",\n          \"to\": \"string\",\n          \"toAccountType\": \"ACCOUNT_TYPE_UNSPECIFIED\",\n          \"asset\": \"string\",\n          \"amount\": \"string\",\n          \"reference\": \"string\",\n          \"oneOff\": {\n            \"deliverOn\": \"string\"\n          },\n          \"recurring\": {\n            \"startEpoch\": \"string\",\n            \"endEpoch\": \"string\",\n            \"factor\": \"string\",\n            \"dispatchStrategy\": {\n              \"assetForMetric\": \"string\",\n              \"metric\": \"DISPATCH_METRIC_UNSPECIFIED\",\n              \"markets\": [\n                \"string\"\n              ]\n            }\n          }\n        },\n        \"cancelTransfer\": {\n          \"transferId\": \"string\"\n        },\n        \"announceNode\": {\n          \"vegaPubKey\": \"string\",\n          \"ethereumAddress\": \"string\",\n          \"chainPubKey\": \"string\",\n          \"infoUrl\": \"string\",\n          \"country\": \"string\",\n          \"id\": \"string\",\n          \"name\": \"string\",\n          \"avatarUrl\": \"string\",\n          \"vegaPubKeyIndex\": 0,\n          \"fromEpoch\": \"string\",\n          \"ethereumSignature\": {\n            \"value\": \"string\",\n            \"algo\": \"string\",\n            \"version\": 0\n          },\n          \"vegaSignature\": {\n            \"value\": \"string\",\n            \"algo\": \"string\",\n            \"version\": 0\n          },\n          \"submitterAddress\": \"string\"\n        },\n        \"batchMarketInstructions\": {\n          \"cancellations\": [\n            {\n              \"orderId\": \"string\",\n              \"marketId\": \"string\"\n            }\n          ],\n          \"amendments\": [\n            {\n              \"orderId\": \"string\",\n              \"marketId\": \"string\",\n              \"price\": \"string\",\n              \"sizeDelta\": \"string\",\n              \"expiresAt\": \"string\",\n              \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n              \"peggedOffset\": \"string\",\n              \"peggedReference\": \"PEGGED_REFERENCE_UNSPECIFIED\"\n            }\n          ],\n          \"submissions\": [\n            {\n              \"marketId\": \"string\",\n              \"price\": \"string\",\n              \"size\": \"string\",\n              \"side\": \"SIDE_UNSPECIFIED\",\n              \"timeInForce\": \"TIME_IN_FORCE_UNSPECIFIED\",\n              \"expiresAt\": \"string\",\n              \"type\": \"TYPE_UNSPECIFIED\",\n              \"reference\": \"string\",\n              \"peggedOrder\": {\n                \"reference\": \"PEGGED_REFERENCE_UNSPECIFIED\",\n                \"offset\": \"string\"\n              }\n            }\n          ]\n        },\n        \"nodeVote\": {\n          \"reference\": \"string\"\n        },\n        \"nodeSignature\": {\n          \"id\": \"string\",\n          \"sig\": \"string\",\n          \"kind\": \"NODE_SIGNATURE_KIND_UNSPECIFIED\"\n        },\n        \"chainEvent\": {\n          \"txId\": \"string\",\n          \"nonce\": \"string\",\n          \"builtin\": {\n            \"deposit\": {\n              \"vegaAssetId\": \"string\",\n              \"partyId\": \"string\",\n              \"amount\": \"string\"\n            },\n            \"withdrawal\": {\n              \"vegaAssetId\": \"string\",\n              \"partyId\": \"string\",\n              \"amount\": \"string\"\n            }\n          },\n          \"erc20\": {\n            \"index\": \"string\",\n            \"block\": \"string\",\n            \"assetList\": {\n              \"vegaAssetId\": \"string\",\n              \"assetSource\": \"string\"\n            },\n            \"assetDelist\": {\n              \"vegaAssetId\": \"string\"\n            },\n            \"deposit\": {\n              \"vegaAssetId\": \"string\",\n              \"sourceEthereumAddress\": \"string\",\n              \"targetPartyId\": \"string\",\n              \"amount\": \"string\"\n            },\n            \"withdrawal\": {\n              \"vegaAssetId\": \"string\",\n              \"targetEthereumAddress\": \"string\",\n              \"referenceNonce\": \"string\"\n            },\n            \"assetLimitsUpdated\": {\n              \"vegaAssetId\": \"string\",\n              \"sourceEthereumAddress\": \"string\",\n              \"lifetimeLimits\": \"string\",\n              \"withdrawThreshold\": \"string\"\n            },\n            \"bridgeStopped\": true,\n            \"bridgeResumed\": true\n          },\n          \"stakingEvent\": {\n            \"index\": \"string\",\n            \"block\": \"string\",\n            \"stakeDeposited\": {\n              \"ethereumAddress\": \"string\",\n              \"vegaPublicKey\": \"string\",\n              \"amount\": \"string\",\n              \"blockTime\": \"string\"\n            },\n            \"stakeRemoved\": {\n              \"ethereumAddress\": \"string\",\n              \"vegaPublicKey\": \"string\",\n              \"amount\": \"string\",\n              \"blockTime\": \"string\"\n            },\n            \"totalSupply\": {\n              \"tokenAddress\": \"string\",\n              \"totalSupply\": \"string\"\n            }\n          },\n          \"erc20Multisig\": {\n            \"index\": \"string\",\n            \"block\": \"string\",\n            \"signerAdded\": {\n              \"newSigner\": \"string\",\n              \"nonce\": \"string\",\n              \"blockTime\": \"string\"\n            },\n            \"signerRemoved\": {\n              \"oldSigner\": \"string\",\n              \"nonce\": \"string\",\n              \"blockTime\": \"string\"\n            },\n            \"thresholdSet\": {\n              \"newThreshold\": 0,\n              \"nonce\": \"string\",\n              \"blockTime\": \"string\"\n            }\n          }\n        },\n        \"keyRotateSubmission\": {\n          \"newPubKeyIndex\": 0,\n          \"targetBlock\": \"string\",\n          \"newPubKey\": \"string\",\n          \"currentPubKeyHash\": \"string\"\n        },\n        \"stateVariableProposal\": {\n          \"proposal\": {\n            \"stateVarId\": \"string\",\n            \"eventId\": \"string\",\n            \"kvb\": [\n              {\n                \"key\": \"string\",\n                \"tolerance\": \"string\",\n                \"value\": {\n                  \"scalarVal\": {\n                    \"value\": \"string\"\n                  },\n                  \"vectorVal\": {\n                    \"value\": [\n                      \"string\"\n                    ]\n                  },\n                  \"matrixVal\": {\n                    \"value\": [\n                      {\n                        \"value\": [\n                          \"string\"\n                        ]\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"validatorHeartbeat\": {\n          \"nodeId\": \"string\",\n          \"ethereumSignature\": {\n            \"value\": \"string\",\n            \"algo\": \"string\",\n            \"version\": 0\n          },\n          \"vegaSignature\": {\n            \"value\": \"string\",\n            \"algo\": \"string\",\n            \"version\": 0\n          }\n        },\n        \"ethereumKeyRotateSubmission\": {\n          \"targetBlock\": \"string\",\n          \"newAddress\": \"string\",\n          \"currentAddress\": \"string\",\n          \"submitterAddress\": \"string\"\n        },\n        \"protocolUpgradeProposal\": {\n          \"upgradeBlockHeight\": \"string\",\n          \"vegaReleaseTag\": \"string\"\n        },\n        \"issueSignatures\": {\n          \"submitter\": \"string\",\n          \"kind\": \"NODE_SIGNATURE_KIND_UNSPECIFIED\",\n          \"validatorNodeId\": \"string\"\n        },\n        \"oracleDataSubmission\": {\n          \"source\": \"ORACLE_SOURCE_UNSPECIFIED\",\n          \"payload\": \"string\"\n        }\n      }\n    }\n  ]\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"default"} value={"default"}><div>

An unexpected error response.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"code"} required={false} schemaDescription={undefined} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"message"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>details</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"@type"} required={false} schemaDescription={undefined} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"code\": 0,\n  \"message\": \"string\",\n  \"details\": [\n    {\n      \"@type\": \"string\"\n    }\n  ]\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem></ApiTabs></div>
      